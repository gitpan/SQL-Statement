.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Statement::Functions 3"
.TH SQL::Statement::Functions 3 "2010-08-01" "perl v5.13.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Statement::Functions \- built\-in & user\-defined SQL functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& SELECT Func(args);
\& SELECT * FROM Func(args);
\& SELECT * FROM x WHERE Funcs(args);
\& SELECT * FROM x WHERE y < Funcs(args);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains the built-in functions for SQL::Parser and SQL::Statement.  All of the functions are also available in any DBDs that subclass those modules (e.g. \s-1DBD::CSV\s0, \s-1DBD::DBM\s0, DBD::File, DBD::AnyData, DBD::Excel, etc.).
.PP
This documentation covers built-in functions and also explains how to create your own functions to supplement the built-in ones.  It's easy.  If you create one that is generally useful, see below for how to submit it to become a built-in function.
.SH "Function syntax"
.IX Header "Function syntax"
When using SQL::Statement/SQL::Parser directly to parse \s-1SQL\s0, functions (either built-in or user-defined) may occur anywhere in a \s-1SQL\s0 statement that values, column names, table names, or predicates may occur.  When using the modules through a \s-1DBD\s0 or in any other context in which the \s-1SQL\s0 is both parsed and executed, functions can occur in the same places except that they can not occur in the column selection clause of a \s-1SELECT\s0 statement that contains a \s-1FROM\s0 clause.
.PP
.Vb 1
\& # valid for both parsing and executing
\&
\&     SELECT MyFunc(args);
\&     SELECT * FROM MyFunc(args);
\&     SELECT * FROM x WHERE MyFuncs(args);
\&     SELECT * FROM x WHERE y < MyFuncs(args);
\&
\& # valid only for parsing (won\*(Aqt work from a DBD)
\&
\&     SELECT MyFunc(args) FROM x WHERE y;
.Ve
.SH "User-Defined Functions"
.IX Header "User-Defined Functions"
.SS "Loading User-Defined Functions"
.IX Subsection "Loading User-Defined Functions"
In addition to the built-in functions, you can create any number of your own user-defined functions (UDFs).  In order to use a \s-1UDF\s0 in a script, you first have to create a perl subroutine (see below), then you need to make the function available to your database handle with the \s-1CREATE\s0 \s-1FUNCTION\s0 or \s-1LOAD\s0 commands:
.PP
.Vb 2
\& # load a single function "foo" from a subroutine
\& # named "foo" in the current package
\&
\&      $dbh\->do(" CREATE FUNCTION foo EXTERNAL ");
\&
\& # load a single function "foo" from a subroutine
\& # named "bar" in the current package
\&
\&      $dbh\->do(" CREATE FUNCTION foo EXTERNAL NAME bar");
\&
\&
\& # load a single function "foo" from a subroutine named "foo"
\& # in another package
\&
\&      $dbh\->do(\*(Aq CREATE FUNCTION foo EXTERNAL NAME "Bar::Baz::foo" \*(Aq);
\&
\& # load all the functions in another package
\&
\&      $dbh\->do(\*(Aq LOAD "Bar::Baz" \*(Aq);
.Ve
.PP
Functions themselves should follow \s-1SQL\s0 identifier naming rules.  Subroutines loaded with \s-1CREATE\s0 \s-1FUNCTION\s0 can have any valid perl subroutine name.  Subroutines loaded with \s-1LOAD\s0 must start with \s-1SQL_FUNCTION_\s0 and then the actual function name.  For example:
.PP
.Vb 5
\& package Qux::Quimble;
\& sub SQL_FUNCTION_FOO { ... }
\& sub SQL_FUNCTION_BAR { ... }
\& sub some_other_perl_subroutine_not_a_function { ... }
\& 1;
\&
\& # in another package
\& $dbh\->do("LOAD Qux::Quimble");
\&
\& # This loads FOO and BAR as SQL functions.
.Ve
.SS "Creating User-Defined Functions"
.IX Subsection "Creating User-Defined Functions"
User-defined functions (UDFs) are perl subroutines that return values appropriate to the context of the function in a \s-1SQL\s0 statement.  For example the built-in \s-1CURRENT_TIME\s0 returns a string value and therefore may be used anywhere in a \s-1SQL\s0 statement that a string value can.  Here' the entire perl code for the function:
.PP
.Vb 8
\& # CURRENT_TIME
\& #
\& # arguments : none
\& # returns   : string containing current time as hh::mm::ss
\& #
\& sub SQL_FUNCTION_CURRENT_TIME {
\&     sprintf "%02s::%02s::%02s",(localtime)[2,1,0]
\& }
.Ve
.PP
More complex functions can make use of a number of arguments always passed to functions automatically.  Functions always receive these values in \f(CW@_:\fR
.PP
.Vb 3
\& sub FOO {
\&     my($self,$sth,$rowhash,@params);
\& }
.Ve
.PP
The first argument, \f(CW$self\fR, is whatever class the function is defined in, not generally useful unless you have an entire module to support the function.
.PP
The second argument, \f(CW$sth\fR is the active statement handle of the current statement.  Like all active statement handles it contains the current database handle in the {Database} attribute so you can have access to the database handle in any function:
.PP
.Vb 5
\& sub FOO {
\&     my($self,$sth,$rowhash,@params);
\&     my $dbh = $sth\->{Database};
\&     # $dbh\->do( ...), etc.
\& }
.Ve
.PP
In actual practice you probably want to use \f(CW$sth\fR\-{Database} directly rather than making a local copy, so \f(CW$sth\fR\->{Database}\->do(...).
.PP
The third argument, \f(CW$rowhash\fR, is a reference to a hash containing the key/value pairs for the current database row the \s-1SQL\s0 is searching.  This isn't relevant for something like \s-1CURRENT_TIME\s0 which isn't based on a \s-1SQL\s0 search, but here's an example of a (rather useless) \s-1UDF\s0 using \f(CW$rowhash\fR that just joins the values for the entire row with a colon:
.PP
.Vb 4
\& sub COLON_JOIN {
\&     my($self,$sth,$rowhash,@params);
\&     my $str = join \*(Aq:\*(Aq, values %$rowhash;
\& }
.Ve
.PP
The remaining arguments, \f(CW@params\fR, are arguments passed by users to the function, either directly or with placeholders; another silly example which just returns the results of multiplying the arguments passed to it:
.PP
.Vb 4
\& sub MULTIPLY {
\&     my($self,$sth,$rowhash,@params);
\&     return $params[0] * $params[1];
\& }
\&
\& # first make the function available
\& #
\& $dbh\->do("CREATE FUNCTION MULTIPLY");
\&
\& # then multiply col3 in each row times seven
\& #
\& my $sth=$dbh\->prepare("SELECT col1 FROM tbl1 WHERE col2 = MULTIPLY(col3,7)");
\& $sth\->execute;
\& #
\& # or
\& #
\& my $sth=$dbh\->prepare("SELECT col1 FROM tbl1 WHERE col2 = MULTIPLY(col3,?)");
\& $sth\->execute(7);
.Ve
.SS "Creating In-Memory Tables with functions"
.IX Subsection "Creating In-Memory Tables with functions"
A function can return almost anything, as long is it is an appropriate return for the context the function will be used in.  In the special case of table-returning functions, the function should return a reference to an array of array references with the first row being the column names and the remaining rows the data.  For example:
.PP
\&\fB1. create a function that returns an AoA\fR,
.PP
.Vb 7
\&  sub Japh {[
\&      [qw( id word   )],
\&      [qw( 1 Hacker  )],
\&      [qw( 2 Perl    )],
\&      [qw( 3 Another )],
\&      [qw( 4 Just    )],
\&  ]}
.Ve
.PP
\&\fB2. make your database handle aware of the function\fR
.PP
.Vb 1
\&  $dbh\->do("CREATE FUNCTION \*(AqJaph\*(Aq);
.Ve
.PP
\&\fB3. Access the data in the AoA from \s-1SQL\s0\fR
.PP
.Vb 1
\&  $sth = $dbh\->prepare("SELECT word FROM Japh ORDER BY id DESC");
.Ve
.PP
Or here's an example that does a join on two in-memory tables:
.PP
.Vb 4
\&  sub Prof  {[ [qw(pid pname)],[qw(1 Sue )],[qw(2 Bob)],[qw(3 Tom )] ]}
\&  sub Class {[ [qw(pid cname)],[qw(1 Chem)],[qw(2 Bio)],[qw(2 Math)] ]}
\&  $dbh\->do("CREATE FUNCTION $_) for qw(Prof Class);
\&  $sth = $dbh\->prepare("SELECT * FROM Prof NATURAL JOIN Class");
.Ve
.PP
The \*(L"Prof\*(R" and \*(L"Class\*(R" functions return tables which can be used like any \s-1SQL\s0 table.
.PP
More complex functions might do something like scrape an \s-1RSS\s0 feed, or search a file system and put the results in AoA.  For example, to search a directory with \s-1SQL:\s0
.PP
.Vb 10
\& sub Dir {
\&     my($self,$sth,$rowhash,$dir)=@_;
\&     opendir D, $dir or die "\*(Aq$dir\*(Aq:$!";
\&     my @files = readdir D;
\&     my $data = [[qw(fileName fileExt)]];
\&     for (@files) {
\&         my($fn,$ext) = /^(.*)(\e.[^\e.]+)$/;
\&         push @$data, [$fn,$ext];
\&     }
\&     return $data;
\& }
\& $dbh\->do("CREATE FUNCTION Dir");
\& printf "%s\en", join\*(Aq   \*(Aq,@{ $dbh\->selectcol_arrayref("
\&     SELECT fileName FROM Dir(\*(Aq./\*(Aq) WHERE fileExt = \*(Aq.pl\*(Aq
\& ")};
.Ve
.PP
Obviously, that function could be expanded with File::Find and/or stat to provide more information and it could be made to accept a list of directories rather than a single directory.
.PP
Table-Returning functions are a way to turn *anything* that can be modeled as an AoA into a \s-1DBI\s0 data source.
.SH "Built-in Functions"
.IX Header "Built-in Functions"
.SS "Aggregate Functions"
.IX Subsection "Aggregate Functions"
\fImin, max, avg, sum, count\fR
.IX Subsection "min, max, avg, sum, count"
.PP
Aggregate functions are handled elsewhere, see SQL::Parser for documentation.
.SS "Date and Time Functions"
.IX Subsection "Date and Time Functions"
\fIcurrent_date, current_time, current_timestamp\fR
.IX Subsection "current_date, current_time, current_timestamp"
.PP
\&\fB\s-1CURRENT_DATE\s0\fR
.PP
.Vb 3
\& # purpose   : find current date
\& # arguments : none
\& # returns   : string containing current date as yyyy\-mm\-dd
.Ve
.PP
\&\fB\s-1CURRENT_TIME\s0\fR
.PP
.Vb 3
\& # purpose   : find current time
\& # arguments : none
\& # returns   : string containing current time as hh::mm::ss
.Ve
.PP
\&\fB\s-1CURRENT_TIMESTAMP\s0\fR
.PP
.Vb 3
\& # purpose   : find current date and time
\& # arguments : none
\& # returns   : string containing current timestamp as yyyy\-mm\-dd hh::mm::ss
.Ve
.SS "String Functions"
.IX Subsection "String Functions"
\fIchar_length, lower, position, regex, soundex, substring, trim, upper\fR
.IX Subsection "char_length, lower, position, regex, soundex, substring, trim, upper"
.PP
\&\fB\s-1CHAR_LENGTH\s0\fR
.PP
.Vb 3
\& # purpose   : find length in characters of a string
\& # arguments : a string
\& # returns   : a number \- the length of the string in characters
.Ve
.PP
\&\fB\s-1LOWER\s0 & \s-1UPPER\s0\fR
.PP
.Vb 3
\& # purpose   : lower\-case or upper\-case a string
\& # arguments : a string
\& # returns   : the sting lower or upper cased
.Ve
.PP
\&\fB\s-1POSITION\s0\fR
.PP
.Vb 4
\& # purpose   : find first position of a substring in a string
\& # arguments : a substring and  a string possibly containing the substring
\& # returns   : a number \- the index of the substring in the string
\& #             or 0 if the substring doesn\*(Aqt occur in the sring
.Ve
.PP
\&\fB\s-1REGEX\s0\fR
.PP
.Vb 6
\& # purpose   : test if a string matches a perl regular expression
\& # arguments : a string and a regex to match the string against
\& # returns   : boolean value of the regex match
\& #
\& # example   : ... WHERE REGEX(col3,\*(Aq/^fun/i\*(Aq) ... matches rows
\& #             in which col3 starts with "fun", ignoring case
.Ve
.PP
\&\fB\s-1SOUNDEX\s0\fR
.PP
.Vb 6
\& # purpose   : test if two strings have matching soundex codes
\& # arguments : two strings
\& # returns   : true if the strings share the same soundex code
\& #
\& # example   : ... WHERE SOUNDEX(col3,\*(Aqfun\*(Aq) ... matches rows
\& #             in which col3 is a soundex match for "fun"
.Ve
.PP
\&\fB\s-1CONCAT\s0\fR
.PP
.Vb 8
\& # purpose   : concatenate 1 or more strings into a single string;
\& #                      an alternative to the \*(Aq||\*(Aq operator
\& # arguments : 1 or more strings
\& # returns   : the concatenated string
\& #
\& # example   : SELECT CONCAT(first_string, \*(Aqthis string\*(Aq, \*(Aq that string\*(Aq)
\& #              returns "<value\-of\-first\-string>this string that string"
\& # note      : if any argument evaluates to NULL, the returned value is NULL
.Ve
.PP
\&\fB\s-1COALESCE\s0\fR \fIaka\fR \fB\s-1NVL\s0\fR
.PP
.Vb 7
\& # purpose   : return the first non\-NULL value from a list
\& # arguments : 1 or more expressions
\& # returns   : the first expression (reading left to right)
\& #             which is not NULL; returns NULL if all are NULL
\& #
\& # example   : SELECT COALESCE(NULL, some_null_column, \*(Aqnot null\*(Aq)
\& #              returns \*(Aqnot null\*(Aq
.Ve
.PP
\&\fB\s-1DECODE\s0\fR
.PP
.Vb 10
\& # purpose   : compare the first argument against
\& #             succeding arguments at position 1 + 2N
\& #             (N = 0 to (# of arguments \- 2)/2), and if equal,
\& #                              return the value of the argument at 1 + 2N + 1; if no
\& #             arguments are equal, the last argument value is returned
\& # arguments : 4 or more expressions, must be even # of arguments
\& # returns   : the value of the argument at 1 + 2N + 1 if argument 1 + 2N
\& #             is equal to argument1; else the last argument value
\& #
\& # example   : SELECT DECODE(some_column,
\& #                    \*(Aqfirst value\*(Aq, \*(Aqfirst value matched\*(Aq
\& #                    \*(Aq2nd value\*(Aq, \*(Aq2nd value matched\*(Aq
\& #                    \*(Aqno value matched\*(Aq
\& #                    )
.Ve
.PP
\&\fB\s-1REPLACE\s0\fR, \fB\s-1SUBSTITUTE\s0\fR
.PP
.Vb 7
\& # purpose   : perform perl subsitution on input string
\& # arguments : a string and a substitute pattern string
\& # returns   : the result of the substitute operation
\& #
\& # example   : ... WHERE REPLACE(col3,\*(Aqs/fun(\ew+)nier/$1/ig\*(Aq) ... replaces
\& #                      all instances of /fun(\ew+)nier/ in col3 with the string
\& #                      between \*(Aqfun\*(Aq and \*(Aqnier\*(Aq
.Ve
.PP
\&\fB\s-1SUBSTRING\s0\fR
.PP
.Vb 1
\&  SUBSTRING( string FROM start_pos [FOR length] )
.Ve
.PP
Returns the substring starting at start_pos and extending for
\&\*(L"length\*(R" character or until the end of the string, if no
\&\*(L"length\*(R" is supplied.  Examples:
.PP
.Vb 1
\&  SUBSTRING( \*(Aqfoobar\*(Aq FROM 4 )       # returns "bar"
\&
\&  SUBSTRING( \*(Aqfoobar\*(Aq FROM 4 FOR 2)  # returns "ba"
.Ve
.PP
Note: The \s-1SUBSTRING\s0 function is implemented in SQL::Parser and SQL::Statement and, at the current time, can not be over-ridden.
.PP
\&\fB\s-1TRIM\s0\fR
.PP
.Vb 1
\&  TRIM ( [ [LEADING|TRAILING|BOTH] [\*(Aqtrim_char\*(Aq] FROM ] string )
.Ve
.PP
Removes all occurrences of <trim_char> from the front, back, or
both sides of a string.
.PP
.Vb 1
\& BOTH is the default if neither LEADING nor TRAILING is specified.
\&
\& Space is the default if no trim_char is specified.
\&
\& Examples:
\&
\& TRIM( string )
\&   trims leading and trailing spaces from string
\&
\& TRIM( LEADING FROM str )
\&   trims leading spaces from string
\&
\& TRIM( \*(Aqx\*(Aq FROM str )
\&   trims leading and trailing x\*(Aqs from string
.Ve
.PP
Note: The \s-1TRIM\s0 function is implemented in SQL::Parser and SQL::Statement and, at the current time, can not be over-ridden.
.SH "Special Utility Functions"
.IX Header "Special Utility Functions"
.SS "\s-1\fIIMPORT\s0()\fP"
.IX Subsection "IMPORT()"
.Vb 2
\& CREATE TABLE foo AS IMPORT(?)    ,{},$external_executed_sth
\& CREATE TABLE foo AS IMPORT(?)    ,{},$AoA
.Ve
.SH "Submitting built-in functions"
.IX Header "Submitting built-in functions"
There are a few built-in functions in the SQL::Statement::Functions.  If you make a generally useful \s-1UDF\s0, why not submit it to me and have it (and your name) included with the built-in functions?  Please follow the format shown in the module including a description of the arguments and return values for the function as well as an example.  Send them to me at jzucker \s-1AT\s0 cpan.org with a subject line containing \*(L"built-in \s-1UDF\s0\*(R".
.PP
Thanks in advance :\-).
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Dean Arnold supplied \s-1DECODE\s0, \s-1COALESCE\s0, \s-1REPLACE\s0, many thanks!
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Copyright (c) 2005 by Jeff Zucker: jzuckerATcpan.org
Copyright (c) 2009,2010 by Jens Rehsack: rehsackATcpan.org
.PP
All rights reserved.
.PP
The module may be freely distributed under the same terms as
Perl itself using either the \*(L"\s-1GPL\s0 License\*(R" or the \*(L"Artistic
License\*(R" as specified in the Perl \s-1README\s0 file.
